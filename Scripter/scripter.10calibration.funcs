#!/bin/bash
# scripter.xxx.funcs functions
# This is reloaded at every new MS in a scripter run
# It defines some standard processing steps

# these aren't really processing steps per set, but useful functions called by processing steps

# runs the imager over the current MS, field and spwid. Remaining arguments need to be supplied,
imager()
{
  $RUNIMAGER ms=$MSNAME $FIELD_IMG $SPWID_IMG $*
}
# runs plot-ms over the current MS, field and spwid. Remaining arguments need to be supplied,
plot-ms()
{
  $PLOTMS $MSNAME -F $field -D $MS_DDID -I "$IFRS" -L $FQSLICE_OC $*
}

## reset_ms: removes MS, untars copy from tgz, adds bitflags, fixes WSRT UVWs, etc.
reset_ms()
{
  rm -fr $MSNAME
  (cd `dirname $MSNAME` && tar zxvf `basename $MSNAME`.tgz)
  wsrt_j2convert msin=$MSNAME
  addbitflagcol $MSNAME
  python -c "import pyrap.tables;pyrap.tables.addImagingColumns('$MSNAME')"
  $DOWNWEIGH -I "$IFRS" $MSNAME
  init_flags
}

## init_flags: called to apply initial flagging to an MS
# Default version is a no-op. You may redefine this in scripter.YOURPROJ.funcs
init_flags ()
{
  /bin/true
}

##
reset_mep()
{
  rm -fr $MSNAME/*mep
  if [ -d ${LSM%.html}.fmep ]; then
    rm -fr ${LSM%.html}.fmep
  fi
}

reset_g ()
{
  rm -fr $MSNAME/G*mep
}

reset_de ()
{
  rm -fr $MSNAME/dE*mep
}

#restore_lsm ()
#{
#  tar zxvf qmc2.fmep.band$DDID.tgz
#}

restore_g ()
{
  tar zxvf $SAVED_SOLUTIONS_DIR/G_${OUTFILE}_*.tgz
}

clip_residuals ()
{
  /bin/true
}

cal_generic ()
{
  label=$1
  section=$2
  jobname=$3
  parmtab=$4
  shift 4
  time meqtree-pipeliner.py $MT -c $CONFIG \
    \[$section\] \
    $MS_TDL $CHAN_TDL $LSM_TDL $* \
    enable_inspectors=${ENABLE_INSPECTORS:-0} \
    $SCRIPTNAME \
    =$jobname
  clip_residuals $MSNAME $label
  plot-ms CORRECTED_DATA:I -o $DESTDIR/${OUTFILE}_residuals_${step}_${label}.png
  imager name_dirty=$DESTDIR/${OUTFILE}_${step}_${label}
  step=$[$step+1];
  true
}

cal_g ()
{
  cal_generic G ${cal_g_section:-cal_g} cal_G_diag G_diag.fmep $*
  if [ "$ENABLE_PARM_PLOTS" == "1" ]; then
    $PLOTPARMS $MSNAME/G_diag.fmep "*:*:*/ampl" $plot_Gampl_options -o $DESTDIR/${OUTFILE}_${step}_Ga.png
    $PLOTPARMS $MSNAME/G_diag.fmep "*:*:*/phase" $plot_Gphase_options -o $DESTDIR/${OUTFILE}_${step}_Gp.png
  fi
  tar zcvf $DESTDIR/G_${OUTFILE}_step$step.tgz $MSNAME/G_diag.fmep
}

cal_ig ()
{
  cal_generic IG ${cal_ig_section:-cal_ig} cal_IG IG.fmep $*
  tar zcvf $DESTDIR/IG_${OUTFILE}_step$step.tgz $MSNAME/IG.fmep
}

cal_de ()
{
  cal_generic dE ${cal_de_section:-cal_de} cal_dE_diag dE_diag.fmep $*
  if [ "$ENABLE_PARM_PLOTS" == "1" ]; then
    $PLOTPARMS $MSNAME/dE_ampl.fmep "*:*:*:*/ampl"  $plot_dEampl_options -o $DESTDIR/${OUTFILE}_${step}_dEa.png
    $PLOTPARMS $MSNAME/dE_phase.fmep "*:*:*:*/phase" $plot_dEphase_options -o $DESTDIR/${OUTFILE}_${step}_dEp.png
  fi
  tar zcvf $DESTDIR/dE_${OUTFILE}_step$step.tgz $MSNAME/dE_diag.fmep
}

cal_de_ampl ()
{
  cal_generic dEa ${cal_de_ampl_section:-cal_de_ap} cal_dE_ampl dE_ampl.fmep $*
  if [ "$ENABLE_PARM_PLOTS" == "1" ]; then
    $PLOTPARMS $MSNAME/dE_ampl.fmep "*:*:*:*/ampl"  $plot_dEampl_options -o $DESTDIR/${OUTFILE}_${step}_dEa.png
  fi
  tar zcvf $DESTDIR/dEa_${OUTFILE}_step$step.tgz $MSNAME/dE_ampl.fmep
}

cal_de_phase ()
{
  cal_generic dEp ${cal_de_phase_section:-cal_de_ap} cal_dE_phase dE_phase.fmep $*
  if [ "$ENABLE_PARM_PLOTS" == "1" ]; then
    $PLOTPARMS $MSNAME/dE_phase.fmep "*:*:*:*/phase" $plot_dEphase_options -o $DESTDIR/${OUTFILE}_${step}_dEp.png
  fi
  tar zcvf $DESTDIR/dEp_${OUTFILE}_step$step.tgz $MSNAME/dE_phase.fmep
}

redo_plot_ms ()
{
  if [ "$1" != "" ]; then
    suffix="_$1"
  else
    suffix=""
  fi
  plot-ms ${2:-CORRECTED_DATA:I} -o $DESTDIR/${OUTFILE}${suffix}.png
}

make_image ()
{
  imager name_dirty=$DESTDIR/${OUTFILE}_${step}
}

genvis_generic ()
{
  label=$1
  section=$2
  shift 2
  time meqtree-pipeliner.py $MT -c $CONFIG \
    \[$section\] \
    $MS_TDL $CHAN_TDL $LSM_TDL $* \
    enable_inspectors=${ENABLE_INSPECTORS:-0} \
    $SCRIPTNAME \
    =generate_visibilities
  imager name_dirty=$DESTDIR/${OUTFILE}_${label}_step$step
  step=$[$step+1];
  true
}

make_corr_data ()
{
  genvis_generic corr_data ${make_corr_data_section:-make_corr_data} $*
}

make_residuals ()
{
  genvis_generic residual ${make_residuals_section:-make_residuals} $*
}

## update_flags: readjusts flags on an MS post-calibration
# Default version is a no-op. You may redefine this in scripter.YOURPROJ.funcs
update_flags()
{
  /bin/true
}


### "global" functions applying to full MSs

merge_ms()
{
  $MERGEMS -f ${1-$FULLMS} $MSNAMES
  update_flags ${1-$FULLMS}
}

make_image()
{
  ms=`basename $MSNAME .MS`
  if [ "$MSNAME" == "$FULLMS" ]; then
    sz="size=$FULL_SIZE"
  else
    unset sz
  fi
  $RUNIMAGER ms=$MSNAME name_dirty=$DESTDIR/${ms%.ms}_dirty $sz $*
}

make_clean()
{
  ms=`basename $MSNAME .MS`
  if [ "$MSNAME" == "$FULLMS" ]; then
    sz="size=$FULL_SIZE"
  else
    unset sz
  fi
  $RUNIMAGER ms=$MSNAME oper=csclean \
    name_restored=$DESTDIR/${ms%.ms}_restored \
    name_residual=$DESTDIR/${ms%.ms}_residual \
    name_model=$DESTDIR/${ms%.ms}_model \
    $sz $*
}

make_psf_image ()
{
  ms=`basename $MSNAME .MS`
  _psf_image="${ms%.ms}_psf"
  name=${1-$_psf_image}
  shift 1
  $RUNIMAGER ms=$MSNAME data=psf name_dirty=${name%.fits} size=$PSF_SIZE flux_scale=1 $*
}

make_restored_image ()
{
  ms=`basename $MSNAME .MS`
  psf_image="${ms%.ms}_psf.fits"
  if [ ! -f $psf_image ]; then
    make_psf_image $psf_image
  fi
  $TIGGER_RESTORE $DESTDIR/${ms%.ms}_restored.fits $LSM $DESTDIR/${ms%.ms}_model_restored.fits -p $psf_image -f
}

make_ssms ()
{
  if [ "$1" == "" ]; then
    echo "make_ssms: must be invoked with a source name";
    exit 1
  fi
  make_residuals "tiggerlsm.null_subset=$1*" "do_correct_sky=$1*"
}

make_full_ssms ()
{
  if [ "$1" == "" ]; then
    echo "make_full_ssms: must be invoked with a source name";
    exit 1
  fi
  per_ms step=1 make_ssms[$1]
  merge_ms ${FULLMS%.MS}_src$1.MS
}

extract_ss_ccm ()
{
  srcname="$1"
  oper="${2-image+clark}"
  ms=${FULLMS%.MS}_src$1.MS
  shift 2
  if [ "$srcname" == "" ]; then
    echo "extract_ss_ccm: must be invoked with a source name (and optional clean operation)";
    exit 1
  fi
  if [ ! -d $ms ]; then
    echo "extract_ss_ccm: $ms does not exist."
    echo "Perhaps run make_full_ssms first?"
    exit 1;
  fi
  # extract source coords
  python >.coords.$srcname <<-end
import Tigger
src=[src for src in Tigger.load("$LSM",verbose=0).sources if src.name.startswith("$srcname")]
src=sorted(src,lambda a,b:cmp(b.Iapp,a.Iapp))
src=src[0]
print "j2000,%dh%dm%fs,%s%dd%dm%fs"%tuple(list(src.pos.ra_hms())+list(src.pos.dec_sdms()))
end
  # go through intermediate file and take its tail, because the front may have bullshit messages
  coords=`tail -1 .coords.$srcname`
  rm .coords.$srcname
  if [ "${coords#j2000}" == "$coords"  ]; then
    echo "Failed to extract coordinate of source $srcname from LSM file $LSM"
    exit 1
  fi
  echo ":::Extracting clean component model for source $srcname at $coords"
  # make filename template
  assign_templates SSCCM_Template
  if [ ! -d `dirname $SSCCM` ]; then
    mkdir `dirname $SSCCM`
  fi
  # make images
  for op in ${oper//+/ }; do
    $RUNIMAGER ms=$ms phasecenter=$coords size=$SOURCE_CC_SIZE \
      name_dirty=${SSCCM}-dirty \
      name_restored=${SSCCM}-restored \
      name_residual=${SSCCM}-residual \
      name_model=${SSCCM}-cc \
      prefervelocity=False \
      oper=$op flux_scale=1 $*
  done
  # due to an lwimager bug, the center frequency is not assigned correctly -- fix it here
  _freq=`python -c "import pyrap.tables;print pyrap.tables.table('$ms/SPECTRAL_WINDOW').getcol('REF_FREQUENCY')[${SPWID_IMG#*=}]"|tail -1`
  echo "Center frequency is $_freq"
  echo $FITSTOOL -E RESTFREQ=$_freq -E ALTRVAL=$_freq ${SSCCM}-cc.fits -f
  # remove MS
  if [ "$KEEP_POSTAGE_STAMP_MS" == "" -o "$KEEP_POSTAGE_STAMP_MS" == "0" ]; then
    rm -fr $ms
  fi
}

get_ssccm_list ()
{
  if [ "$1" == "" -o "$1" == "-" ]; then
    _out=`python -c "import Tigger;mod=Tigger.load('$LSM');print ','.join(sorted(set([(getattr(src,'cluster',None) or src.name) for src in mod.sources if getattr(src,'postage_stamp',False)])))"|tail -1`
#    if [ "$SSCCM_LIST" != "" ]; then
#      _out=$SSCCM_LIST
#    else
#      _out=${SSCCM_PER_SPW[$ddid]}
#    fi
  else
    _out=$1
  fi
  echo ${_out//,/ }
  # python -c "import Tigger;mod=Tigger.load('A773comp-spw2.lsm.html');print set([src.name[0] for src in mod.sources if getattr(src,'dE',False)])"
}

make_and_extract_ss_ccm ()
{
  SOURCES="`get_ssccm_list $1`"
  LSM1="${2:-$LSM}"
  if [ "$LSM1" != "$LSM" ]; then
    cp $LSM $LSM1
    LSM="$LSM1"
  fi
  shift 2
  for srcname in $SOURCES; do
    # set $_dE to "dE:" if source has a dE tag -- this will get passed on to its brick, below
    python >.dE.$srcname <<-end
import Tigger
src=[src for src in Tigger.load("$LSM",verbose=0).sources if src.name.startswith("$srcname")]
src=sorted(src,lambda a,b:cmp(b.Iapp,a.Iapp))
print ':dE:' if hasattr(src[0],'dE') else ':'
end
    _dE=`cat .dE.$srcname|tail -1`
    rm .dE.$srcname
    echo "Extracting SSCCM for source '$srcname' $_dE"
    make_full_ssms $srcname
    extract_ss_ccm $srcname $*  #NB: this also sets up $SSCCM to the proper path
    # insert source -- notw how dE tag gets propagated
    echo $TIGGER_CONVERT $LSM $LSM -f --remove-source "$srcname*" --add-brick $srcname-cc:${SSCCM}-cc.fits:${_dE}brick
    $TIGGER_CONVERT $LSM $LSM -f --remove-source "$srcname*" --add-brick $srcname-cc:${SSCCM}-cc.fits:${_dE}brick
  done
}

